#!/opt/mesosphere/bin/python3

import argparse
import json
import os
import re
import shutil
import subprocess
import sys

from datetime import datetime
from itertools import chain
from math import floor
from string import Template


PROG = os.path.basename(__file__)

JSON_COMMON_TEMPLATE = Template('''
{
    "name": "disk",
    "role": "$role",
    "scalar": {
        "value": $disk_size
    },
    "type": "SCALAR"
}
''')

JSON_DISK_TEMPLATE = Template('''
{
    "disk": {
        "source": {
            "type": "MOUNT",
            "mount": {
                "root": "$mp"
            }
        }
    }
}
''')

MOUNT_PATTERN = re.compile('on\s+(/dcos/volume\d+)\s+', re.M | re.I)

# Conversion factor for Bytes -> MB calculation
MB = float(1 << 20)

# We leave 5GB free (or 50% of the disk, whichever is smaller) for the root
# disk so Mesos has enough headroom for e.g., checkpointing before sandbox GC.
ROOT_TOLERANCE_MB = 5000
ROOT_TOLERANCE_FACTOR = 2

# We require at least 100MB for mount volumes.
#
# TODO(chhsiao): This requirement seems unnecessary. Consider removing it.
MOUNT_TOLERANCE_MB = 100

RESOURCES_TEMPLATE_HEADER = '''# Generated by {prog} on {dt}
#
'''

RESOURCES_TEMPLATE = '''
MESOS_RESOURCES='{res}'
'''


class VolumeDiscoveryException(Exception):
    pass


def find_mounts_matching(pattern):
    '''
    Find all matching mounts from the output of the mount command
    '''
    print('Looking for mounts matching pattern "{}"'.format(pattern.pattern))
    mounts = subprocess.check_output(['mount'], universal_newlines=True)
    return pattern.findall(mounts)


def make_disk_resources_json(mounts, role):
    '''
    Disk resources are defined in https://mesos.apache.org/documentation/latest/multiple-disk/

    Substitute discovered mounts into JSON_TEMPLATE, returning a list of Mounts

    @type mounts: tuple(mount_point, disk_size_in_mb)
    @rtype: list
    '''
    for (mp, ds) in mounts:
        common = JSON_COMMON_TEMPLATE.substitute(disk_size=ds, role=role)
        disk = JSON_DISK_TEMPLATE.substitute(mp=mp)
        yield json.loads(common), json.loads(disk)


def get_disk_size(path):
    '''
    @type path: str

    @rtype tuple
    '''
    stat = os.statvfs(path)
    return floor(float(stat.f_frsize * stat.f_blocks) / MB)


def get_mounts_and_disksize(matching_mounts, cache_volumes):
    '''
    If the size of a reserved mount volume changes (due to e.g., kernel
    upgrades or changes in the disk size detection logic), Mesos will fail to
    re-apply the reservation because it does not tolerate changes in the amount
    of disk space for mount volumes (DCOS_OSS-3921). This is why we keep a cache
    and use the previous amount of disk space.
    '''
    for mount in matching_mounts:
        if mount in cache_volumes:
            net_disk_size = cache_volumes[mount]
        else:
            net_disk_size = get_disk_size(mount) - MOUNT_TOLERANCE_MB

        if net_disk_size <= 0:
            # Per @cmaloney and @lingmann, we should hard exit here if volume
            # doesn't have sufficient space.
            raise VolumeDiscoveryException(
                '{} has {} MB disk, expected > {}M'.format( mount,
                    net_disk_size + MOUNT_TOLERANCE_MB,
                    MOUNT_TOLERANCE_MB
                )
            )
        yield (mount, net_disk_size)


def _handle_root_volume(root_volume, role, cache_volumes):
    os.makedirs(root_volume, exist_ok=True)

    if root_volume in cache_volumes:
        net_disk_size = cache_volumes[root_volume]
    else:
        total_size = get_disk_size(root_volume)
        if total_size >= ROOT_TOLERANCE_MB * ROOT_TOLERANCE_FACTOR:
            net_disk_size = total_size - ROOT_TOLERANCE_MB
        else:
            net_disk_size = total_size / ROOT_TOLERANCE_FACTOR

    for common, _ in make_disk_resources_json([(root_volume, net_disk_size)], role):
        yield common, {}


def stitch(parts):
    common, disk = parts
    common.update(disk)
    return common


def main(output_env_file, cache_env_file):
    '''
    Find mounts and disk size matching MOUNT_PATTERN, create RESOURCES for the
    disks, and merge the list of disk resources with optionally existing
    MESOS_RESOURCES environment variable.

    @type output_env_file: str, filename to write resources
    '''
    if os.path.exists(output_env_file):
        print('Volume discovery assumed to be completed because {} exists'.format(output_env_file))
        return

    cache_volumes = {}
    if os.path.exists(cache_env_file):
        print('Importing Mesos resources cache from {}'.format(cache_env_file))
        with open(cache_env_file) as f:
            data = None
            # The Mesos resources file is not a clean JSON file, it has comments
            # and quotation marks that need to be filtered. This is why we
            # enumerate the file instead of loading it entirely as a JSON file.
            #
            # Changing the formatting of the file could break the caching logic
            # but test_make_disk_resources in DC/OS EE should detect such a bug.
            for _, line in enumerate(f):
                if line.startswith('MESOS_RESOURCES'):
                    data = json.loads(line[len('MESOS_RESOURCES=\''):-2])
            for item in data:
                if item["name"] == "disk":
                    if "disk" in item:
                        # This is a mount volume.
                        assert "source" in item["disk"]
                        assert "mount" in item["disk"]["source"]
                        assert "root" in item["disk"]["source"]["mount"]
                        mount_volume = item["disk"]["source"]["mount"]["root"]
                        cache_volumes[mount_volume] = item["scalar"]["value"]
                    else:
                        # This is a root volume.
                        root_volume = os.environ['MESOS_WORK_DIR']
                        cache_volumes[root_volume] = item["scalar"]["value"]


    current_mounts = find_mounts_matching(MOUNT_PATTERN)
    mounts_dsize = list(get_mounts_and_disksize(current_mounts, cache_volumes))
    print('Found matching mounts : {}'.format(mounts_dsize))

    role = os.getenv('MESOS_DEFAULT_ROLE', '*')

    disk_resources = list(
        map(
            stitch, chain(
                make_disk_resources_json(mounts_dsize, role),
                _handle_root_volume(os.environ['MESOS_WORK_DIR'], role, cache_volumes)
            )
        )
    )
    print('Generated disk resources map: {}'.format(disk_resources))

    # write contents to a temporary file
    tmp_file = '{}.tmp'.format(output_env_file)
    with open(tmp_file, 'w') as env_file:
        env_file.write(RESOURCES_TEMPLATE_HEADER.format(prog=PROG, dt=datetime.now()))
        if disk_resources:
            msg = 'Creating updated environment artifact file : {}'
            env_resources = os.environ.get('MESOS_RESOURCES', '[]')
            try:
                resources = json.loads(env_resources)
            except ValueError as e:
                print('ERROR: Invalid MESOS_RESOURCES JSON {} --- {}'.format(e, env_resources), file=sys.stderr)
                sys.exit(1)
            resources.extend(disk_resources)
            env_file.write(RESOURCES_TEMPLATE.format(res=json.dumps(resources)))
        else:
            msg = 'No additional volumes. Empty artifact file {} created'

    print(msg.format(output_env_file))

    # Now rename tmp file to final file. This guarantees that anything reading
    # this file never sees a "partial" version of the file. It either doesn't
    # exist or it is there with full contents.
    os.rename(tmp_file, output_env_file)


if __name__ == '__main__':
    PARSER = argparse.ArgumentParser()
    PARSER.add_argument("output", help="file where to write resources")
    PARSER.add_argument("--cache", help="file containing the Mesos resources cache")
    ARGS = PARSER.parse_args()

    if not ARGS.cache:
        # By default, the path of the cache is <ouput_file_path>.cache.
        ARGS.cache = '{}.cache'.format(ARGS.output)

    try:
        main(ARGS.output, ARGS.cache)
    except VolumeDiscoveryException as err:
        print('ERROR: {}'.format(err), file=sys.stderr)
        sys.exit(1)
